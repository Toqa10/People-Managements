# -*- coding: utf-8 -*-
"""HR.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BRPDra8Zdc_vshxER2aey6dnJ-HG5b7a
"""

# Commented out IPython magic to ensure Python compatibility.
# import streamlit as st
# import pandas as pd
# import joblib
# 
# # تحميل الموديل المدرب
# model = joblib.load('risk_model.pkl')
# 
# # عنوان التطبيق
# st.title("🎯 Employee Risk Prediction App")
# 
# st.write("Upload employee data to predict their risk score.")
# 
# # تحميل البيانات من المستخدم
# uploaded_file = st.file_uploader("📤 Upload a CSV file", type=["csv"])
# 
# if uploaded_file is not None:
#     data = pd.read_csv(uploaded_file)
#     st.write("✅ Uploaded Data Preview:")
#     st.write(data.head())
# 
#     # تحديد الأعمدة المطلوبة
#     expected_cols = ['gender', 'title', 'dept_name', 'tenure', 'amount', 'num_promotions']
# 
#     # التحقق إن كل الأعمدة موجودة
#     if all(col in data.columns for col in expected_cols):
#         # التأكد من الترتيب
#         input_data = data[expected_cols]
# 
#         # التعامل مع الترميز (لو دربتي الموديل على بيانات مش مرمزة قوليلي)
#         # هنا بنفترض الترميز في مرحلة التدريب
# 
#         # التنبؤ
#         predictions = model.predict(input_data)
# 
#         # عرض النتائج
#         data['Predicted Risk'] = predictions
#         st.success("✅ Predictions completed!")
#         st.write(data)
# 
#         # تحميل النتائج
#         csv = data.to_csv(index=False)
#         st.download_button("⬇️ Download Results as CSV", data=csv, file_name="risk_predictions.csv", mime="text/csv")
#     else:
#         st.error("❌ Please upload a CSV file with the correct columns: " + ", ".join(expected_cols))
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import joblib
# 
# df = pd.read_csv("employee.csv")
# 
# model = joblib.load("rf_model.pkl")
# 
# st.title("🚨 HR Risk Prediction App")
# 
# row = st.selectbox("اختر رقم الموظف للتنبؤ بالمخاطر", df.index)
# 
# if st.button("تنبأ"):
#     input_data = df.drop(columns=["risk_score"]).iloc[[row]]
#     prediction = model.predict(input_data)[0]
#     st.success(f"تقييم المخاطر المتوقع: {prediction}")
#
# --- Streamlit HR Analytics App ---
# --- Streamlit HR Analytics App ---
# --- Streamlit HR Analytics App ---
# --- Streamlit HR Analytics App ---
# --- HR Analytics Streamlit App ---
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import io

# تهيئة الصفحة
st.set_page_config(page_title="HR Insights", layout="wide")
sns.set_style("whitegrid")

# --- تحميل البيانات ---
@st.cache_data
def load_data():
    def read_file(name):
        try:
            return pd.read_csv(name)
        except FileNotFoundError:
            return pd.DataFrame()

    return (
        read_file("current_employee_snapshot.csv"),
        read_file("department_employee.csv"),
        read_file("employee.csv"),
        read_file("department.csv"),
        read_file("salary.csv"),
        read_file("title.csv"),
        read_file("department_manager.csv"),
    )

current_emp_snapshot, department_employee, employee, department, salary, title, department_manager = load_data()

# --- معالجة مسبقة للبيانات ---
if not salary.empty:
    salary['year'] = pd.to_datetime(salary['from_date']).dt.year
    salary_sorted = salary.sort_values(['employee_id', 'from_date'])
    salary_sorted['prev_salary'] = salary_sorted.groupby('employee_id')['amount'].shift(1)
    salary_sorted['salary_growth'] = salary_sorted['amount'] - salary_sorted['prev_salary']
    salary_sorted['growth_year'] = pd.to_datetime(salary_sorted['from_date']).dt.year
else:
    salary_sorted = pd.DataFrame()

# أفضل الرواتب حسب القسم - مع التحقق من وجود الأعمدة
if not current_emp_snapshot.empty:
    required_columns = ['dept_name', 'salary_amount']
    if all(col in current_emp_snapshot.columns for col in required_columns):
        top_10 = current_emp_snapshot.groupby("dept_name", as_index=False).apply(
            lambda x: x.nlargest(10, "salary_amount")
        ).reset_index(drop=True)
    else:
        st.warning("البيانات لا تحتوي على الأعمدة المطلوبة لعرض أفضل الرواتب")
        top_10 = pd.DataFrame()
else:
    top_10 = pd.DataFrame()

# --- دالة مساعدة لحفظ المخططات ---
def fig_to_image(fig):
    buf = io.BytesIO()
    fig.savefig(buf, format="png", bbox_inches='tight')
    buf.seek(0)
    return buf

# --- واجهة التطبيق ---
st.title("📊 لوحة تحليل الموارد البشرية")
st.markdown("اطرح سؤالاً للحصول على رؤى مرئية من بيانات الموظفين")

# عرض الأعمدة المتاحة لتصحيح الأخطاء
if not current_emp_snapshot.empty:
    with st.expander("عرض الأعمدة المتاحة في البيانات"):
        st.write("أعمدة بيانات الموظفين الحاليين:", current_emp_snapshot.columns.tolist())

question = st.text_input("❓ اطرح سؤالاً عن بيانات الموظفين")

# الأسئلة المدعومة
allowed_questions = {
    "top salaries": "أعلى الرواتب حسب القسم",
    "highest paid": "أعلى الرواتب حسب القسم",
    "salary growth": "نمو الرواتب السنوي",
    "average salary per gender": "متوسط الراتب حسب الجنس",
    "gender salary": "متوسط الراتب حسب الجنس",
    "tenure vs salary": "الخبرة مقابل الراتب"
}

# --- معالجة الأسئلة ---
if question:
    q = question.lower()
    matched = [key for key in allowed_questions if key in q]

    if matched:
        chart_title = allowed_questions[matched[0]]
        st.success(f"✅ عرض مخطط لـ: {chart_title}")
        fig, ax = plt.subplots(figsize=(10, 5))

        if "salary growth" in matched[0]:
            if not salary_sorted.empty and 'growth_year' in salary_sorted.columns:
                avg_growth = salary_sorted.groupby("growth_year")["salary_growth"].mean().reset_index()
                sns.lineplot(data=avg_growth, x="growth_year", y="salary_growth", marker='o', ax=ax)
                ax.set_title("📈 متوسط نمو الرواتب السنوي")
                st.pyplot(fig)
                st.download_button("⬇️ تحميل المخطط", data=fig_to_image(fig), file_name="salary_growth.png", mime="image/png")
            else:
                st.error("بيانات نمو الرواتب غير متوفرة أو غير مكتملة")

        elif "top salaries" in matched[0] or "highest paid" in matched[0]:
            if not top_10.empty and all(col in top_10.columns for col in ['dept_name', 'salary_amount']):
                top10_plot = top_10.groupby("dept_name").head(1).sort_values("salary_amount", ascending=False)
                sns.barplot(data=top10_plot, x="dept_name", y="salary_amount", ax=ax)
                ax.set_title("🏆 أعلى الموظفين راتباً حسب القسم")
                plt.xticks(rotation=45)
                st.pyplot(fig)
                st.download_button("⬇️ تحميل المخطط", data=fig_to_image(fig), file_name="top_salaries.png", mime="image/png")
            else:
                st.error("بيانات أعلى الرواتب غير متوفرة أو غير مكتملة")

        elif "gender salary" in matched[0] or "average salary per gender" in matched[0]:
            if not current_emp_snapshot.empty and all(col in current_emp_snapshot.columns for col in ['gender', 'salary_amount']):
                sns.barplot(data=current_emp_snapshot, x="gender", y="salary_amount", estimator='mean', ax=ax)
                ax.set_title("⚖️ متوسط الراتب حسب الجنس")
                st.pyplot(fig)
                st.download_button("⬇️ تحميل المخطط", data=fig_to_image(fig), file_name="gender_salary.png", mime="image/png")
            else:
                st.error("بيانات الرواتب حسب الجنس غير متوفرة أو غير مكتملة")

        elif "tenure vs salary" in matched[0]:
            if not current_emp_snapshot.empty and all(col in current_emp_snapshot.columns for col in ['tenure', 'salary_amount']):
                current_emp_snapshot_clean = current_emp_snapshot.dropna(subset=["tenure", "salary_amount"])
                sns.scatterplot(data=current_emp_snapshot_clean, x="tenure", y="salary_amount", ax=ax)
                ax.set_title("📉 العلاقة بين الخبرة والراتب")
                st.pyplot(fig)
                st.download_button("⬇️ تحميل المخطط", data=fig_to_image(fig), file_name="tenure_vs_salary.png", mime="image/png")
            else:
                st.error("بيانات الخبرة والرواتب غير متوفرة أو غير مكتملة")

    else:
        st.warning("⚠️ هذا السؤال غير مدعوم أو البيانات المطلوبة غير متاحة")
        st.write("الأسئلة المدعومة:")
        for q, desc in allowed_questions.items():
            st.write(f"- {q}: {desc}")
