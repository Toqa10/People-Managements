# -*- coding: utf-8 -*-
"""HR.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BRPDra8Zdc_vshxER2aey6dnJ-HG5b7a
"""

# Commented out IPython magic to ensure Python compatibility.
# import streamlit as st
# import pandas as pd
# import joblib
# 
# # تحميل الموديل المدرب
# model = joblib.load('risk_model.pkl')
# 
# # عنوان التطبيق
# st.title("🎯 Employee Risk Prediction App")
# 
# st.write("Upload employee data to predict their risk score.")
# 
# # تحميل البيانات من المستخدم
# uploaded_file = st.file_uploader("📤 Upload a CSV file", type=["csv"])
# 
# if uploaded_file is not None:
#     data = pd.read_csv(uploaded_file)
#     st.write("✅ Uploaded Data Preview:")
#     st.write(data.head())
# 
#     # تحديد الأعمدة المطلوبة
#     expected_cols = ['gender', 'title', 'dept_name', 'tenure', 'amount', 'num_promotions']
# 
#     # التحقق إن كل الأعمدة موجودة
#     if all(col in data.columns for col in expected_cols):
#         # التأكد من الترتيب
#         input_data = data[expected_cols]
# 
#         # التعامل مع الترميز (لو دربتي الموديل على بيانات مش مرمزة قوليلي)
#         # هنا بنفترض الترميز في مرحلة التدريب
# 
#         # التنبؤ
#         predictions = model.predict(input_data)
# 
#         # عرض النتائج
#         data['Predicted Risk'] = predictions
#         st.success("✅ Predictions completed!")
#         st.write(data)
# 
#         # تحميل النتائج
#         csv = data.to_csv(index=False)
#         st.download_button("⬇️ Download Results as CSV", data=csv, file_name="risk_predictions.csv", mime="text/csv")
#     else:
#         st.error("❌ Please upload a CSV file with the correct columns: " + ", ".join(expected_cols))
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import joblib
# 
# df = pd.read_csv("employee.csv")
# 
# model = joblib.load("rf_model.pkl")
# 
# st.title("🚨 HR Risk Prediction App")
# 
# row = st.selectbox("اختر رقم الموظف للتنبؤ بالمخاطر", df.index)
# 
# if st.button("تنبأ"):
#     input_data = df.drop(columns=["risk_score"]).iloc[[row]]
#     prediction = model.predict(input_data)[0]
#     st.success(f"تقييم المخاطر المتوقع: {prediction}")
#
# --- Streamlit HR Analytics App ---
# --- Streamlit HR Analytics App ---
# --- Streamlit HR Analytics App ---
# --- Streamlit HR Analytics App ---
# --- HR Analytics Streamlit App ---
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import io

st.set_page_config(page_title="HR Analytics App", layout="wide")
st.title("📊 HR Insights & Analytics")
st.markdown("Ask HR-related questions and get instant chart-based answers.")

# --- Load Data ---
@st.cache_data
def load_data():
    try:
        current_emp_snapshot = pd.read_csv("current_employee_snapshot.csv")
    except FileNotFoundError:
        current_emp_snapshot = pd.DataFrame()

    try:
        department_employee = pd.read_csv("department_employee.csv")
    except FileNotFoundError:
        department_employee = pd.DataFrame()

    try:
        employee = pd.read_csv("employee.csv")
    except FileNotFoundError:
        employee = pd.DataFrame()

    try:
        department = pd.read_csv("department.csv")
    except FileNotFoundError:
        department = pd.DataFrame()

    try:
        salary = pd.read_csv("salary.csv")
    except FileNotFoundError:
        salary = pd.DataFrame()

    try:
        title = pd.read_csv("title.csv")
    except FileNotFoundError:
        title = pd.DataFrame()

    try:
        department_manager = pd.read_csv("department_manager.csv")
    except FileNotFoundError:
        department_manager = pd.DataFrame()

    return current_emp_snapshot, department_employee, employee, department, salary, title, department_manager

current_emp_snapshot, department_employee, employee, department, salary, title, department_manager = load_data()

# --- Preprocessing ---
if not salary.empty:
    salary['year'] = pd.to_datetime(salary['from_date']).dt.year
    salary_sorted = salary.sort_values(['employee_id', 'from_date'])
    salary_sorted['prev_salary'] = salary_sorted.groupby('employee_id')['amount'].shift(1)
    salary_sorted['salary_growth'] = salary_sorted['amount'] - salary_sorted['prev_salary']
    salary_sorted['growth_year'] = pd.to_datetime(salary_sorted['from_date']).dt.year
else:
    salary_sorted = pd.DataFrame()

# Merge for tenure/salary analysis
merged = salary.merge(title, on='employee_id') if not salary.empty and not title.empty else pd.DataFrame()

# Top 10 highest paid
if not current_emp_snapshot.empty:
    top_10 = current_emp_snapshot.groupby("dept_name", group_keys=False).apply(lambda x: x.sort_values("salary_amount", ascending=False).head(10))
else:
    top_10 = pd.DataFrame()

# --- Questions ---
st.subheader("❓ Ask Your HR Question")
questions = st.text_area("Write one or more questions (each on a new line):", height=150)

allowed_charts = {
    "salary growth": "Average Salary Growth per Year",
    "top salaries": "Top Salaries by Department",
    "highest paid": "Top Salaries by Department",
    "average salary per gender": "Average Salary per Gender",
    "gender salary": "Average Salary per Gender",
    "tenure vs salary": "Tenure vs Salary",
    "average salary per title": "Average Salary per Title",
    "title salary": "Average Salary per Title",
    "employee distribution": "Distribution of Employees per Department",
    "title distribution": "Distribution of Titles"
}

# --- Function to render and save chart ---
def render_chart(fig, description):
    st.pyplot(fig)
    st.markdown(f"**📝 Description:** {description}")
    buf = io.BytesIO()
    fig.savefig(buf, format="png")
    st.download_button("📥 Download Chart as Image", data=buf.getvalue(), file_name="chart.png", mime="image/png")

# --- Handle questions ---
if questions:
    for q in questions.split("\n"):
        q_lower = q.lower().strip()
        matched = [key for key in allowed_charts if key in q_lower]

        if matched:
            st.markdown(f"### ✅ {allowed_charts[matched[0]]}")
            if matched[0] == "salary growth":
                if not salary_sorted.empty:
                    fig, ax = plt.subplots()
                    sns.lineplot(data=salary_sorted, x="growth_year", y="salary_growth", ax=ax)
                    ax.set_title("Average Salary Growth per Year")
                    render_chart(fig, "Tracks how employee salaries increase year over year.")
            elif matched[0] in ["top salaries", "highest paid"]:
                if not top_10.empty:
                    fig, ax = plt.subplots(figsize=(10, 5))
                    top_plot = top_10.groupby("dept_name", as_index=False).first().sort_values("salary_amount", ascending=False)
                    sns.barplot(data=top_plot, x="dept_name", y="salary_amount", ax=ax)
                    ax.set_title("Top Salaries by Department")
                    plt.xticks(rotation=45)
                    render_chart(fig, "Shows highest-paid employees per department.")
            elif matched[0] in ["average salary per gender", "gender salary"]:
                if not current_emp_snapshot.empty:
                    fig, ax = plt.subplots()
                    sns.barplot(data=current_emp_snapshot, x="gender", y="salary_amount", estimator="mean", ax=ax)
                    ax.set_title("Average Salary per Gender")
                    render_chart(fig, "Compares average salaries of male and female employees.")
            elif matched[0] == "tenure vs salary":
                if not current_emp_snapshot.empty:
                    fig, ax = plt.subplots()
                    data = current_emp_snapshot.dropna(subset=["tenure", "salary_amount"])
                    sns.scatterplot(data=data, x="tenure", y="salary_amount", ax=ax)
                    ax.set_title("Tenure vs Salary")
                    render_chart(fig, "Analyzes the relationship between years at company and salary.")
            elif matched[0] in ["average salary per title", "title salary"]:
                if not current_emp_snapshot.empty:
                    fig, ax = plt.subplots()
                    sns.barplot(data=current_emp_snapshot, x="title", y="salary_amount", estimator="mean", ax=ax)
                    plt.xticks(rotation=45)
                    ax.set_title("Average Salary per Title")
                    render_chart(fig, "Average salary by job title.")
            elif matched[0] == "employee distribution":
                if not current_emp_snapshot.empty:
                    fig, ax = plt.subplots()
                    sns.countplot(data=current_emp_snapshot, x="dept_name", order=current_emp_snapshot["dept_name"].value_counts().index, ax=ax)
                    plt.xticks(rotation=45)
                    ax.set_title("Distribution of Employees per Department")
                    render_chart(fig, "Shows number of employees in each department.")
            elif matched[0] == "title distribution":
                if not current_emp_snapshot.empty:
                    fig, ax = plt.subplots()
                    sns.countplot(data=current_emp_snapshot, x="title", order=current_emp_snapshot["title"].value_counts().index, ax=ax)
                    plt.xticks(rotation=45)
                    ax.set_title("Distribution of Titles")
                    render_chart(fig, "Shows how many employees hold each job title.")
        else:
            st.error(f"⚠️ '{q}' is restricted or unsupported.")
